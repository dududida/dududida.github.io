[{"title":"MIT 6.828","date":"2023-01-08T06:50:06.704Z","url":"/2023/01/08/6.828/","categories":["学习记录"],"content":" xv6的安装 关于各种系统调用 Lab util: Unix utilities sleep pingpong primes find xargs Lab：system calls System call tracing Sysinfo Lab: page tables Speed up system calls Print a page table Detecting which pages have been accessed Lab: traps Lab: Copy-on-Write Fork for xv6 Lab: Multithreading Lab: networking Lab: locks Lab: file system Lab: mmap xv6的安装 xv6 book的中文版 条件：Vmware上运行的unbuntu虚拟机 关于各种系统调用 pipe():int pipe(int fds[2]); 在进程的打开文件表中查找前两个可用位置，并将它们分配给管道的读p[0]写p[1]端。 chdir():int chdir(const char *path); 用于改变当前工作目录，其参数为Path 目标目录（类似于cd） Lab util: Unix utilities 以下路径都在xv6-labs-2021/下面 sleepuser/目录下新建sleep.c，代码如下 打开Makefile，在179行找到UPROGS，在其中添加sleep。 回到xv6-labs-2021/，$ make qemu 测试是否通过，在xv6-labs-2021/目录下：$ ./grade-lab-util sleep pingpong不加wait，会出现缓冲区冲突，交替写入。 1.8晚上。自己测试没问题，在进行成绩测试时没通过。 在多次执行pingpong时，输出的pid依次增加，按理说不应该这样。 primes题意：用一堆进程，在他们之间构建pipeline，来构建出一个质数筛选器 参考资料：Bell Labs and CSP Threads 中描述 每个进程打印一个质数，并做一次筛选，剩下的通过管道传到下一个进程 问题在于如何在多个进程间建立起pipeline？ 以下代码参考自知乎-渡船-6.s081 2021 lab1 Xv6 and Unix utilities 我们认为进程统一从pipe1得到数据，将剩余数据传入pipe2 手写画图模拟执行过程 find以官网例子为例，find . b表示在.目录及其子目录下查找名为b的数据文件。反映在argv[]中，即在名为argv[1]目录及其子目录中查找名为argv[2]的数据文件(这点困扰了我很久) 难点在于： 了解LINUX的目录文件的组织结构 读懂ls.c中的ls()中的代码。 xargs完成于2023.2.8 21:42 题意：将来自标准输入的字符串当作命令来执行 难点： 读懂题意，每次读题就要读很久 掌握挨个挨个读取字符的方法，’\\0’和’\\n’的作用 stdin中的一个字符串结束标志就是读到’ ‘，而不是’\\0’，在字符数组中才表现为’\\0’ lab1的重难点总结： 掌握unix下编程的基本格式 掌握父子进程通过管道进行通信的原理并实现通信。 理解linux下文件的组织形式及相关结构体的组成 Lab：system calls参考文件： user/user.h:罗列系统调用的接口 user/usys.pl:配置文件 kernel/syscall.h:罗列系统调用号 System call tracing要点： 命令行中的数，是int32表示，从低位开始依次标号0、1、2、3…31，每一位表示一个系统调用是否跟踪。为1则跟踪，为0则不跟踪。例如trace 32 grep hello README跟踪的是read系统调用，read的系统调用号为5。32在补码的表示下，低6位为100 000。也就是说，它这样表示，其实最多只能跟踪31个系统调用。不过目前只有22个，暂时没有超标。 对user/trace.c的分析： 实现步骤： 在Makefile中，将$U/_trace添加到 UPROGS。 在user/user.h中，添加int trace(int); 在user/usys.pl中，添加entry(&quot;trace&quot;); 在kernel/syscall.h中，添加#define SYS_trace 22 在kernel/proc.h/struct proc中，添加int mask; 在kernel/sysproc.c中，添加函数： 在kernel/proc.c/fork()中，添加： 在kernel/syscall.c中，添加关于sys_trace的信息 扩展kernel/syscall.c/syscall()，在真正执行系统调用之前，若需要跟踪此系统调用，打印跟踪信息 重难点： 了解syscall所经过的路径，一定经过syscall函数进入内核空间。通过ecall指令跳转过去 了解pcb的组成成员以及exec之后，pcb还是原来的pcb Sysinfo目的：打印空闲内存（单位字节）、打印有多少进程的状态是UNUSED 使用copyout()来实现从内核复制数据到用户空间,位于kernel/vm.c中。下面是分析 实现步骤： 在Makefile中，将$U/_sysinfotest添加到 UPROGS。 在user/user.h中，添加int sysinfo(struct sysinfo*);，并且在文件最前面添加struct sysinfo; 在user/usys.pl中，添加entry(&quot;sysinfo&quot;); 在kernel/syscall.h中，添加#define SYS_sysinfo 23 在kernel/kalloc.c中，添加函数： 在kernel/proc.c中，添加函数： 在kernel/defs.h中找到kalloc.c和proc.c的位置，添加刚才添加的函数原型 在kernel/sysproc.c中，添加 在kernel/syscall.c中，添加关于sys_sysinfo的信息。（第一次因为忘了这一步，导致报错unknown sys call 23） 2023.2.18下午完 Lab: page tables！！！注意，在进行每个大实验之前，一定要切换分支 否则代码里根本找不到这次实验需要的结构，比如kernel/memlayout.h/USYSCALL，在切换分支前，根本就没有。 前两个实验没有切换，倒是没有影响。这里要学习git的一些知识，暂时没搞透，搞透了再写写 Speed up system calls目的：加速getid()这个系统调用 大意：有一些内核和用户共享的只读页面，来避免模式切换，以此来加快系统调用。这里在kernel/memlayout.h中给你定义了一个虚拟地址USYSCALL，是一个页面的地址，这个页面最开始的地方，又有一个struct，里面放了一个pid。 实现步骤： // 这里基本是仿照着对trapframe的分配和释放来书写代码，都是分配一个页面，都是里面有一个结构体 在kernel/proc.h/struct proc中添加struct usyscall *usyscall;。（用于指向共享页面） 在kernel/proc.c/allocproc()中添加 在kernel/proc.c/proc_pagetable()中，添加： 在kernrl/proc.c/freeproc()中，添加 在kernel/proc.c/proc_freepagetable()中，添加： 重难点： 理解物理页面的分配和虚拟地址的映射是分两步 了解xv6下虚拟地址空间的组织结构 理解页表的组织结构，就是一个uint64的数组，存放虚拟地址 Print a page table目的：打印pid==1的进程的页表 要点： 这里是多级页表，要依次往下探，所以递归进行 与kernel/vm.c/freewalk()的逻辑和遍历路径一致，freewalk的功能是释放分配给页表的物理内存，取消虚拟地址映射。并且物理内存的释放是从下到上。 实现步骤： 在kernel/exec.c/exec()中的return argc之前，添加： 在kernel/vm.c中实现功能： 在kernel/defs.h中找到vm.c对应得地方，添加对vmprint()的原型说明。 重难点： 了解页表的组织结构，实现对页表的递归遍历并打印层次结构信息。 通过对标识位的逻辑运算，判定PTE是否映射有对象。 Detecting which pages have been accessed目的：检测哪些页面的Accessed标志位为1，这里要了解sv39结构的虚拟地址的组成。 实现思路：大体也就是通过遍历页表，检测标志位 实现步骤： 在kernel/riscv.h中定义Accessed标志位： 在kernel/sysproc.c中实现syscall的外壳： 在kernel/vm.c中实现功能： 在kernel/defs.h中找到vm.c的位置，添加pgaccess()的原型。 ！！注意，这三个实验的验证是通过make qemu，使用pgtaltest命令来验证。 2.22。ugetpid不通过，不知道为啥。 Lab: traps研究系统调用是如何通过traps机制实现的。 关于traps机制：直译陷阱。异常的一种，请结合csapp笔记来看 实现一个用户级的trap handling Lab: Copy-on-Write Fork for xv6就是实现一个写时复制的fork csapp：fork()为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。 它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 Lab: Multithreading实现一个用户级的线程包，来实现线程的切换，以此来加快程序运行速度。并且实现一个mem barrier mem barrier机制 Lab: networking为网络接口控制器写一个设备驱动 Lab: locksparallelism、lock：关于锁和并发。有点复杂。不用写上去，搞不定 Lab: file system为xv6系统添加大文件和符号链接 Lab: mmap"},{"title":"摄影学习笔记","date":"2022-03-14T09:20:30.285Z","url":"/2022/03/14/%E6%91%84%E5%BD%B1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","categories":["杂七杂八"],"content":"如何减少夜景噪点 降低iso (最好不要高于400) 快门速度变慢 (延长曝光时间) 使用三角架 小知识 如果其他参数不变，曝光时间越长，照片就越亮 感光度过高容易产生噪点 名词解释 EV(Exposure Value,曝光值) 基本可以理解为EV越高，拍摄环境的亮度越高。(文章链接：摄影基础文：什么是EV？) "},{"title":"电线杆子上的人","date":"2022-03-08T05:42:23.092Z","url":"/2022/03/08/story_1/","categories":["杂七杂八"],"content":"&emsp;&emsp;电线杆子，一根又一根的电线杆子。电线杆子之间的电线，平行的电线构成了一条直直的，宽敞的道路。&emsp;&emsp;电线杆子上的人就在这样的道路上走着，他们从这里到哪里，他们几乎不休息地走着，他们有时跳跃，有时奔跑。他们偶尔也会停下来，蹲在电线杆子上看着杆子下的人。他们看他们交谈，看他们争吵。&emsp;&emsp;他们真的知道下面的人在讲什么吗？他们不知道，他们是电线杆子上的人，他们只是笑一笑，然后继续向前走去。"}]