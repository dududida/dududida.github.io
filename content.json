{"meta":{"title":"Dududida's blog","subtitle":"","description":"","author":"John Doe","url":"https://dududida.github.io","root":"/"},"pages":[],"posts":[{"title":"MIT 6.828","slug":"6.828","date":"2023-01-08T06:50:06.704Z","updated":"2023-01-27T08:38:05.099Z","comments":true,"path":"2023/01/08/6.828/","link":"","permalink":"https://dududida.github.io/2023/01/08/6.828/","excerpt":"","text":"xv6的安装 条件：Vmware上运行的unbuntu虚拟机 123456789$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu $ git clone git://g.csail.mit.edu/xv6-labs-2021$ cd xv6-labs-2021$ git checkout util$ make qemu ##运行xv6$ Ctrl+a x ##退出xv6 关于各种系统调用 pipe():int pipe(int fds[2]); 在进程的打开文件表中查找前两个可用位置，并将它们分配给管道的读p[0]写p[1]端。 chdir():int chdir(const char *path); 用于改变当前工作目录，其参数为Path 目标目录（类似于cd） 实验 以下路径都在xv6-labs-2021/下面 sleepuser/目录下新建sleep.c，代码如下 1234567891011121314151617#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[])&#123; if(argc&lt;2)&#123; //缺少参数 fprintf(2,&quot;miss argument !\\n&quot;); exit(1); &#125; int time; time = atoi(argv[1]); if(time&lt;0)&#123; //参数不合法 ，实际运行中好像没反应。但是make grade是过了 fprintf(2,&quot;invalid argument !\\n&quot;); exit(1); &#125; sleep(time); exit(0);&#125; 打开Makefile，在179行找到UPROGS，在其中添加sleep。 回到xv6-labs-2021/，$ make qemu 测试是否通过，在xv6-labs-2021/目录下：$ ./grade-lab-util sleep pingpong不加wait，会出现缓冲区冲突，交替写入。 1.8晚上。自己测试没问题，在进行成绩测试时没通过。 在多次执行pingpong时，输出的pid依次增加，按理说不应该这样。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc,char *argv[])&#123; int p1[2]; //pipe1 int p2[2]; //pipe2 pipe(p1); pipe(p2); int pid; char readBuffer[20]; int rsize; if(fork()===0)&#123; pid = getpid(); close(p1[1]); close(p2[0]); write(p2[1],&quot;p&quot;,1); rsize = read(p1[0],readBuffer,1); if(rsize)&#123; fprintf(1,&quot;%d:received ping\\n&quot;,pid); exit(0); &#125; exit(1); &#125; pid = getpid(); close(p1[0]); close(p2[1]); write(p1[1],&quot;p&quot;,1); int userStat; wait(&amp;userStat); rsize = read(p2[0],readBuffer,1); if(rsize)&#123; fprintf(1,&quot;%d:received pong\\n&quot;,pid); exit(0); &#125; exit(1);&#125; primes题意：用一堆进程，在他们之间构建pipeline，来构建出一个质数筛选器 参考资料：Bell Labs and CSP Threads 中描述 123456p = get a number from left neighborprint ploop: n = get a number from left neighbor if (p does not divide n) send n to right neighbor 每个进程打印一个质数，并做一次筛选，剩下的通过管道传到下一个进程 问题在于如何在多个进程间建立起pipeline？ 以下代码参考自知乎-渡船-6.s081 2021 lab1 Xv6 and Unix utilities 我们认为进程统一从pipe1得到数据，将剩余数据传入pipe2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#define READ 0#define WRITE 1#define NULL (int *)0int main(int argc, char *argv[])&#123; int pipe1[2]; pipe(pipe1); int pid = fork(); if (pid &gt; 0) &#123; // 父进程(0)里面 close(pipe1[READ]); // 关闭父进程的读端 for (int i = 2; i &lt;= 35; i++) &#123; write(pipe1[WRITE], &amp;i, sizeof(int)); &#125; // 写入完毕，关闭父进程写端，释放出文件描述符 close(pipe1[WRITE]); wait(NULL); // 有一个子进程退出，这个父进程即退出 exit(0); &#125; else &#123; // 子进程里面，他们的行为是类似的 int min; close(pipe1[WRITE]); // 关闭写入端 //注意，这时子进程(0)的状态，与后面所有后代进程进入循环的初始状态一致 while (read(pipe1[READ], &amp;min, sizeof(int))) &#123; // 能从管道里读出数据，就继续执行 printf(&quot;prime %d\\n&quot;, min); int pipe2[2]; //用于往后传 pipe(pipe2); int i; while (read(pipe1[READ], &amp;i, sizeof(int))) &#123; if (i % min) &#123; // 除不尽 write(pipe2[WRITE], &amp;i, sizeof(int)); &#125; &#125; close(pipe2[WRITE]); // 向子进程写完了，关闭 int pid2 = fork(); // 子1再fork if (pid2 == 0) &#123; // 子(2)进程里面 pipe1[READ] = dup(pipe2[READ]); /* ！！！ 这里非常关键，这一步将fd[READ]指向pipe2的读端。 使得后续进程从pipe1里去读时，实际读的是其父进程的pipe2 */ close(pipe2[READ]); &#125; else &#123; close(pipe2[READ]); wait(NULL); exit(0); //pipe1销毁，因为已经没有文件描述符指向它 &#125; &#125; exit(0); &#125; exit(0);&#125; 手写画图模拟执行过程 find以官网例子为例，find . b表示在.目录及其子目录下查找名为b的数据文件。反映在argv[]中，即在名为argv[1]目录及其子目录中查找名为argv[2]的数据文件(这点困扰了我很久) 难点在于： 了解LINUX的目录文件的组织结构 读懂ls.c中的ls()中的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;void find(char *path, char *fname)&#123; char buf[512], *p; // buf存的是路径字符串 int fd; struct dirent de; struct stat st; if ((fd = open(path, 0)) &lt; 0) // 打开文件 &#123; fprintf(2, &quot;find: cannot open %s\\n&quot;, path); return; &#125; if (fstat(fd, &amp;st) &lt; 0) // 把文件中的信息存入结构体st中 &#123; fprintf(2, &quot;find: cannot stat %s\\n&quot;, path); close(fd); return; &#125; /* 根据fs.h Directory is a file containing a sequence of dirent structures. 即目录文件是一个包含了一系列dirent这个结构体的文件，dirent结构体中有inum和name */ //这里与ls.c中的区别：不需要switch // DIRSIZ在fs.h中定义，大小为14 // 传入的path即是当前的路径字符串 if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf) &#123; printf(&quot;find: path too long\\n&quot;); break; &#125; strcpy(buf, path); // 将path复制到buf p = buf + strlen(buf); /* 这是在初始化p指针，将p指向buf的数据的最后。 buf是数组的起始地址，strlen(buf)是已存放数据的长度。 */ *p++ = &#x27;/&#x27;; // 在后面加上‘/’ while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) // 读取sizeof(dirent)大小的数据，即一个文件 &#123; /* de.inum==0表示这是一块已经初始化并且可以 用来创建文件或者文件夹的位置，应当无视这一块空间 */ if (de.inum == 0) continue; memmove(p, de.name, DIRSIZ); // p就是用于访问buf的指针，往路径后面添加 p[DIRSIZ] = 0; // 这是在干啥？处理某种潜在的bug if (stat(buf, &amp;st) &lt; 0) // stat()用于获取文件信息，参数1就是文件路径名 &#123; printf(&quot;find: cannot stat %s\\n&quot;, buf); continue; &#125; if ((strcmp(de.name, fname) == 0) &amp;&amp; (st.type == T_FILE)) // 数据文件 &#123; printf(&quot;%s\\n&quot;, buf); &#125; if ((st.type == T_DIR) &amp;&amp; (strcmp(&quot;.&quot;, de.name) != 0) &amp;&amp; (strcmp(&quot;..&quot;, de.name) != 0)) // &#123; // 不能递归. .. find(buf, fname); &#125; &#125; close(fd);&#125;int main(int argc, char *argv[])&#123; if (argc &lt; 2) &#123; printf(&quot;Missing parameters\\n&quot;); exit(0); &#125; /* find函数的行为： 在这个目录里面找。 如果这个目录里面的文件依旧是目录文件，那么递归调用find。 若为文件文件，则与argv[2]的值比对。若匹配，打印路径。退出。 */ find(argv[1], argv[2]); exit(0);&#125;","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://dududida.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"摄影学习笔记","slug":"摄影学习笔记","date":"2022-03-14T09:20:30.285Z","updated":"2023-01-09T13:34:44.253Z","comments":true,"path":"2022/03/14/摄影学习笔记/","link":"","permalink":"https://dududida.github.io/2022/03/14/%E6%91%84%E5%BD%B1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"如何减少夜景噪点 降低iso (最好不要高于400) 快门速度变慢 (延长曝光时间) 使用三角架 小知识 如果其他参数不变，曝光时间越长，照片就越亮 感光度过高容易产生噪点 名词解释 EV(Exposure Value,曝光值) 基本可以理解为EV越高，拍摄环境的亮度越高。(文章链接：摄影基础文：什么是EV？)","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://dududida.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[]},{"title":"电线杆子上的人","slug":"story_1","date":"2022-03-08T05:42:23.092Z","updated":"2023-01-09T13:47:01.871Z","comments":true,"path":"2022/03/08/story_1/","link":"","permalink":"https://dududida.github.io/2022/03/08/story_1/","excerpt":"","text":"&emsp;&emsp;电线杆子，一根又一根的电线杆子。电线杆子之间的电线，平行的电线构成了一条直直的，宽敞的道路。&emsp;&emsp;电线杆子上的人就在这样的道路上走着，他们从这里到哪里，他们几乎不休息地走着，他们有时跳跃，有时奔跑。他们偶尔也会停下来，蹲在电线杆子上看着杆子下的人。他们看他们交谈，看他们争吵。&emsp;&emsp;他们真的知道下面的人在讲什么吗？他们不知道，他们是电线杆子上的人，他们只是笑一笑，然后继续向前走去。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://dududida.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[]}],"categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://dududida.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://dududida.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[]}