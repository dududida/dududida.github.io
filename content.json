{"meta":{"title":"Dududida's blog","subtitle":"","description":"","author":"John Doe","url":"https://dududida.github.io","root":"/"},"pages":[],"posts":[{"title":"MIT 6.828","slug":"6.828","date":"2023-01-08T06:50:06.704Z","updated":"2023-02-27T08:48:54.767Z","comments":true,"path":"2023/01/08/6.828/","link":"","permalink":"https://dududida.github.io/2023/01/08/6.828/","excerpt":"","text":"xv6的安装 关于各种系统调用 Lab util: Unix utilities sleep pingpong primes find xargs Lab：system calls System call tracing Sysinfo Lab: page tables Speed up system calls Print a page table Detecting which pages have been accessed Lab: traps Lab: Copy-on-Write Fork for xv6 Lab: Multithreading Lab: networking Lab: locks Lab: file system Lab: mmap xv6的安装 xv6 book的中文版 条件：Vmware上运行的unbuntu虚拟机 123456789$ sudo apt-get install git build-essential gdb-multiarch qemu-system-misc gcc-riscv64-linux-gnu binutils-riscv64-linux-gnu $ git clone git://g.csail.mit.edu/xv6-labs-2021$ cd xv6-labs-2021$ git checkout util$ make qemu ##运行xv6$ Ctrl+a x ##退出xv6 关于各种系统调用 pipe():int pipe(int fds[2]); 在进程的打开文件表中查找前两个可用位置，并将它们分配给管道的读p[0]写p[1]端。 chdir():int chdir(const char *path); 用于改变当前工作目录，其参数为Path 目标目录（类似于cd） Lab util: Unix utilities 以下路径都在xv6-labs-2021/下面 sleepuser/目录下新建sleep.c，代码如下 1234567891011121314151617#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[])&#123; if(argc&lt;2)&#123; //缺少参数 fprintf(2,&quot;miss argument !\\n&quot;); exit(1); &#125; int time; time = atoi(argv[1]); if(time&lt;0)&#123; //参数不合法 ，实际运行中好像没反应。但是make grade是过了 fprintf(2,&quot;invalid argument !\\n&quot;); exit(1); &#125; sleep(time); exit(0);&#125; 打开Makefile，在179行找到UPROGS，在其中添加sleep。 回到xv6-labs-2021/，$ make qemu 测试是否通过，在xv6-labs-2021/目录下：$ ./grade-lab-util sleep pingpong不加wait，会出现缓冲区冲突，交替写入。 1.8晚上。自己测试没问题，在进行成绩测试时没通过。 在多次执行pingpong时，输出的pid依次增加，按理说不应该这样。 1234567891011121314151617181920212223242526272829303132333435363738394041#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc,char *argv[])&#123; int p1[2]; //pipe1 int p2[2]; //pipe2 pipe(p1); pipe(p2); int pid; char readBuffer[20]; int rsize; if(fork()===0)&#123; pid = getpid(); close(p1[1]); close(p2[0]); write(p2[1],&quot;p&quot;,1); rsize = read(p1[0],readBuffer,1); if(rsize)&#123; fprintf(1,&quot;%d:received ping\\n&quot;,pid); exit(0); &#125; exit(1); &#125; pid = getpid(); close(p1[0]); close(p2[1]); write(p1[1],&quot;p&quot;,1); int userStat; wait(&amp;userStat); rsize = read(p2[0],readBuffer,1); if(rsize)&#123; fprintf(1,&quot;%d:received pong\\n&quot;,pid); exit(0); &#125; exit(1);&#125; primes题意：用一堆进程，在他们之间构建pipeline，来构建出一个质数筛选器 参考资料：Bell Labs and CSP Threads 中描述 123456p = get a number from left neighborprint ploop: n = get a number from left neighbor if (p does not divide n) send n to right neighbor 每个进程打印一个质数，并做一次筛选，剩下的通过管道传到下一个进程 问题在于如何在多个进程间建立起pipeline？ 以下代码参考自知乎-渡船-6.s081 2021 lab1 Xv6 and Unix utilities 我们认为进程统一从pipe1得到数据，将剩余数据传入pipe2 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#define READ 0#define WRITE 1#define NULL (int *)0int main(int argc, char *argv[])&#123; int pipe1[2]; pipe(pipe1); int pid = fork(); if (pid &gt; 0) &#123; // 父进程(0)里面 close(pipe1[READ]); // 关闭父进程的读端 for (int i = 2; i &lt;= 35; i++) &#123; write(pipe1[WRITE], &amp;i, sizeof(int)); &#125; // 写入完毕，关闭父进程写端，释放出文件描述符 close(pipe1[WRITE]); wait(NULL); // 有一个子进程退出，这个父进程即退出 exit(0); &#125; else &#123; // 子进程里面，他们的行为是类似的 int min; close(pipe1[WRITE]); // 关闭写入端 //注意，这时子进程(0)的状态，与后面所有后代进程进入循环的初始状态一致 while (read(pipe1[READ], &amp;min, sizeof(int))) &#123; // 能从管道里读出数据，就继续执行 printf(&quot;prime %d\\n&quot;, min); int pipe2[2]; //用于往后传 pipe(pipe2); int i; while (read(pipe1[READ], &amp;i, sizeof(int))) &#123; if (i % min) &#123; // 除不尽 write(pipe2[WRITE], &amp;i, sizeof(int)); &#125; &#125; close(pipe2[WRITE]); // 向子进程写完了，关闭 int pid2 = fork(); // 子1再fork if (pid2 == 0) &#123; // 子(2)进程里面 pipe1[READ] = dup(pipe2[READ]); /* ！！！ 这里非常关键，这一步将fd[READ]指向pipe2的读端。 使得后续进程从pipe1里去读时，实际读的是其父进程的pipe2 */ close(pipe2[READ]); &#125; else &#123; close(pipe2[READ]); wait(NULL); exit(0); //pipe1销毁，因为已经没有文件描述符指向它 &#125; &#125; exit(0); &#125; exit(0);&#125; 手写画图模拟执行过程 find以官网例子为例，find . b表示在.目录及其子目录下查找名为b的数据文件。反映在argv[]中，即在名为argv[1]目录及其子目录中查找名为argv[2]的数据文件(这点困扰了我很久) 难点在于： 了解LINUX的目录文件的组织结构 读懂ls.c中的ls()中的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#include &quot;kernel/fs.h&quot;void find(char *path, char *fname)&#123; char buf[512], *p; // buf存的是路径字符串 int fd; struct dirent de; struct stat st; if ((fd = open(path, 0)) &lt; 0) // 打开文件 &#123; fprintf(2, &quot;find: cannot open %s\\n&quot;, path); return; &#125; if (fstat(fd, &amp;st) &lt; 0) // 把文件中的信息存入结构体st中 &#123; fprintf(2, &quot;find: cannot stat %s\\n&quot;, path); close(fd); return; &#125; /* 根据fs.h Directory is a file containing a sequence of dirent structures. 即目录文件是一个包含了一系列dirent这个结构体的文件，dirent结构体中有inum和name */ //这里与ls.c中的区别：不需要switch // DIRSIZ在fs.h中定义，大小为14 // 传入的path即是当前的路径字符串 if (strlen(path) + 1 + DIRSIZ + 1 &gt; sizeof buf) &#123; printf(&quot;find: path too long\\n&quot;); break; &#125; strcpy(buf, path); // 将path复制到buf p = buf + strlen(buf); /* 这是在初始化p指针，将p指向buf的数据的最后。 buf是数组的起始地址，strlen(buf)是已存放数据的长度。 */ *p++ = &#x27;/&#x27;; // 在后面加上‘/’ while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) // 读取sizeof(dirent)大小的数据，即一个文件 &#123; /* de.inum==0表示这是一块已经初始化并且可以 用来创建文件或者文件夹的位置，应当无视这一块空间 */ if (de.inum == 0) continue; memmove(p, de.name, DIRSIZ); // p就是用于访问buf的指针，往路径后面添加 p[DIRSIZ] = 0; // 这是在干啥？处理某种潜在的bug if (stat(buf, &amp;st) &lt; 0) // stat()用于获取文件信息，参数1就是文件路径名 &#123; printf(&quot;find: cannot stat %s\\n&quot;, buf); continue; &#125; if ((strcmp(de.name, fname) == 0) &amp;&amp; (st.type == T_FILE)) // 数据文件 &#123; printf(&quot;%s\\n&quot;, buf); &#125; if ((st.type == T_DIR) &amp;&amp; (strcmp(&quot;.&quot;, de.name) != 0) &amp;&amp; (strcmp(&quot;..&quot;, de.name) != 0)) // &#123; // 不能递归. .. find(buf, fname); &#125; &#125; close(fd);&#125;int main(int argc, char *argv[])&#123; if (argc &lt; 2) &#123; printf(&quot;Missing parameters\\n&quot;); exit(0); &#125; /* find函数的行为： 在这个目录里面找。 如果这个目录里面的文件依旧是目录文件，那么递归调用find。 若为文件文件，则与argv[2]的值比对。若匹配，打印路径。退出。 */ find(argv[1], argv[2]); exit(0);&#125; xargs完成于2023.2.8 21:42 题意：将来自标准输入的字符串当作命令来执行 难点： 读懂题意，每次读题就要读很久 掌握挨个挨个读取字符的方法，’\\0’和’\\n’的作用 stdin中的一个字符串结束标志就是读到’ ‘，而不是’\\0’，在字符数组中才表现为’\\0’ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &quot;kernel/param.h&quot;#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;#define NULL (int *)0int main(int argc, char *argv[])&#123; // 进程自动打开0,1,2 // 将argv中的命令行参数读出，放入argvArray数组 char *argvArray[MAXARG]; // 传参都用指针数组传，argv就是一个指针数组。 int i; for (i = 1; i &lt; argc; i++) &#123; argvArray[i-1] = argv[i]; // 注意argv[0]是xargs。不需要 &#125; // 再读stdin里面的参数 char buf[512], *p; // p是用来访问buf的指针 p = buf; // 先指向起始位置 argvArray[argc - 1] = buf; /* 以echo hello too | xargs echo bye为例子 argc为3,但实际上此时argvArray中只有两个参数：echo bye 下一步是在argvArray[2]中继续添加参数 */ int newArgc = argc; //增加后的参数数量 char ch; while (read(0, &amp;ch, sizeof(char))) &#123; if (ch == &#x27; &#x27;) &#123; //代表字符串结束，加上一个&#x27;\\0&#x27; *p = &#x27;\\0&#x27;; p++; //这里p立刻后移，否则下面这一步就指向null了。卡了好久 argvArray[newArgc] = p; //新的argv放入 /* 实际上，buf是一直在向前移，永不后退，也不用清空，buf里面类似于 abc&#x27;\\0&#x27;a&#x27;\\0&#x27; so buffer should be big enough */ newArgc++; &#125; else if(ch == &#x27;\\n&#x27;)&#123; //这时就要fork，执行命令 *p = &#x27;\\0&#x27;; argvArray[newArgc] = 0; //做一个结尾 int pid = fork(); if(pid)&#123; //父进程 wait(NULL); memset(buf,0,sizeof(buf)); //这个时候buffer才清零，不清零应该是会有影响的 p = buf; //指针回溯 newArgc = argc; //这个也回溯 &#125; else&#123; exec(argvArray[0],argvArray); exit(0); &#125; &#125; else&#123; //普通的读取 *p = ch; p++; &#125; &#125; exit(0);&#125; lab1的重难点总结： 掌握unix下编程的基本格式 掌握父子进程通过管道进行通信的原理并实现通信。 理解linux下文件的组织形式及相关结构体的组成 Lab：system calls参考文件： user/user.h:罗列系统调用的接口 user/usys.pl:配置文件 kernel/syscall.h:罗列系统调用号 System call tracing要点： 命令行中的数，是int32表示，从低位开始依次标号0、1、2、3…31，每一位表示一个系统调用是否跟踪。为1则跟踪，为0则不跟踪。例如trace 32 grep hello README跟踪的是read系统调用，read的系统调用号为5。32在补码的表示下，低6位为100 000。也就是说，它这样表示，其实最多只能跟踪31个系统调用。不过目前只有22个，暂时没有超标。 对user/trace.c的分析：1234567891011121314151617181920212223242526272829#include &quot;kernel/param.h&quot;#include &quot;kernel/types.h&quot;#include &quot;kernel/stat.h&quot;#include &quot;user/user.h&quot;int main(int argc, char *argv[])&#123; int i; char *nargv[MAXARG]; if(argc &lt; 3 || (argv[1][0] &lt; &#x27;0&#x27; || argv[1][0] &gt; &#x27;9&#x27;))&#123; //只有两个参数 或者 系统调用号不是数字，报错 fprintf(2, &quot;Usage: %s mask command\\n&quot;, argv[0]); exit(1); &#125; if (trace(atoi(argv[1])) &lt; 0) &#123; //调用trac，说明trace应该是返回int，且-1表示报错。并且trace的作用是设置mask，把argv[1]传进去 fprintf(2, &quot;%s: trace failed\\n&quot;, argv[0]); exit(1); &#125; for(i = 2; i &lt; argc &amp;&amp; i &lt; MAXARG; i++)&#123; //提取出要执行的命令。例子：grep hello README nargv[i-2] = argv[i]; &#125; exec(nargv[0], nargv); /* 调用exec后，调用该函数的进程的虚拟地址空间的代码段、数据段、堆、栈被释放， 替换成新进程的代码段、数据段、堆、栈，而PCB依旧使用之前进程的PCB。所以之前通过 trace设置的mask还在。接下来，当一个进程调用一个系统调用时，我们都通过myproc()获取它的mask。 对比，确认是要跟踪的系统调用，打印信息。 并且要求子进程也跟踪，也就是要继承父进程的pcb中的mask，还要修改 */ exit(0);&#125; 实现步骤： 在Makefile中，将$U/_trace添加到 UPROGS。 在user/user.h中，添加int trace(int); 在user/usys.pl中，添加entry(&quot;trace&quot;); 在kernel/syscall.h中，添加#define SYS_trace 22 在kernel/proc.h/struct proc中，添加int mask; 在kernel/sysproc.c中，添加函数： 1234567uint64 sys_trace(void)&#123; //for lab:TRACE int mask; if(argint(0, &amp;mask) &lt; 0) return -1; myproc()-&gt;mask=mask; return 0;&#125; 在kernel/proc.c/fork()中，添加： 12// Copy mask from parent to child. //for lab:TRACE np-&gt;mask=p-&gt;mask; 在kernel/syscall.c中，添加关于sys_trace的信息 扩展kernel/syscall.c/syscall()，在真正执行系统调用之前，若需要跟踪此系统调用，打印跟踪信息 12345678910111213141516171819202122232425voidsyscall(void)&#123; int num; struct proc *p = myproc(); //获取当前的进程的pcb int mask; char *syscall_name[24]=&#123;0,&quot;fork&quot;,&quot;exit&quot;,&quot;wait&quot;,&quot;pipe&quot;,&quot;read&quot;,&quot;kill&quot;,&quot;exec&quot;, &quot;fstat&quot;,&quot;chdir&quot;,&quot;dup&quot;,&quot;getpid&quot;,&quot;sbrk&quot;,&quot;sleep&quot;,&quot;uptime&quot;, &quot;open&quot;,&quot;write&quot;,&quot;mknod&quot;,&quot;unlink&quot;,&quot;link&quot;,&quot;mkdir&quot;,&quot;close&quot;, &quot;trace&quot;,&quot;sysinfo&quot;&#125;; num = p-&gt;trapframe-&gt;a7; //从a7寄存器取出系统调用号 if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123; //正确，则执行系统调用 p-&gt;trapframe-&gt;a0 = syscalls[num](); &#125; else &#123; printf(&quot;%d %s: unknown sys call %d\\n&quot;, p-&gt;pid, p-&gt;name, num); p-&gt;trapframe-&gt;a0 = -1; &#125; mask=p-&gt;mask; if(mask&amp;1&lt;&lt;num)&#123; //按位与，只要一位对应上，就代表需要跟踪这个系统调用 printf(&quot;%d: syscall %s -&gt; %d\\n&quot;,p-&gt;pid,syscall_name[num],p-&gt;trapframe-&gt;a0); //a0存的是系统调用的返回值 &#125;&#125; 重难点： 了解syscall所经过的路径，一定经过syscall函数进入内核空间。通过ecall指令跳转过去 了解pcb的组成成员以及exec之后，pcb还是原来的pcb Sysinfo目的：打印空闲内存（单位字节）、打印有多少进程的状态是UNUSED 使用copyout()来实现从内核复制数据到用户空间,位于kernel/vm.c中。下面是分析12345678// Copy from kernel to user.// Copy len bytes from src to virtual address dstva in a given page table.// Return 0 on success, -1 on error.intcopyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)// 其中pagetable_t是一个uint64 *// 回顾了一下页表的理论知识，确实就应该是一个数组，每一项表示一个页表条目，最高位表示是否在内存中 实现步骤： 在Makefile中，将$U/_sysinfotest添加到 UPROGS。 在user/user.h中，添加int sysinfo(struct sysinfo*);，并且在文件最前面添加struct sysinfo; 在user/usys.pl中，添加entry(&quot;sysinfo&quot;); 在kernel/syscall.h中，添加#define SYS_sysinfo 23 在kernel/kalloc.c中，添加函数： 123456789101112131415161718/*用户空间分配内存使用malloc，分配的虚拟内存kalloc.c是用来分配内核内存的函数，分配物理内存*/uint64 get_freemem(void) //获得空闲内存的数量，多少字节。&#123; struct run *r; uint64 len=0; acquire(&amp;kmem.lock); //获得锁 r = kmem.freelist; while(r) &#123; r = r-&gt;next; len++; &#125; release(&amp;kmem.lock); return len*PGSIZE; //PGSIZE即页面的大小，为4096。定义在riscv.h里面&#125; 在kernel/proc.c中，添加函数： 123456789101112131415uint64 get_unused_proc(void)&#123; struct proc *p; uint64 num=0; for (p = proc; p &lt; &amp;proc[NPROC]; p++) &#123; acquire(&amp;p-&gt;lock); //这是锁，在struct proc的注释中，有写哪些成员在访问时必须要先获取锁 if (p-&gt;state != UNUSED) &#123; num++; &#125; release(&amp;p-&gt;lock); &#125; return num;&#125; 在kernel/defs.h中找到kalloc.c和proc.c的位置，添加刚才添加的函数原型 在kernel/sysproc.c中，添加 1234567891011121314151617#include &quot;sysinfo.h&quot;uint64 sys_sysinfo(void)&#123; struct sysinfo info; info.freemem=get_freemem(); info.nproc=get_unused_proc(); uint64 user_si; // user pointer to struct sysinfo struct proc *p = myproc(); if(argaddr(0, &amp;user_si) &lt; 0) return -1;//fetch user pointer to struct sysinfo from syscall arg if(copyout(p-&gt;pagetable, user_si, (char *)&amp;info, sizeof(info)) &lt; 0) return -1; return 0;&#125; 在kernel/syscall.c中，添加关于sys_sysinfo的信息。（第一次因为忘了这一步，导致报错unknown sys call 23） 2023.2.18下午完 Lab: page tables！！！注意，在进行每个大实验之前，一定要切换分支 123$ git fetch$ git checkout pgtbl$ make clean 否则代码里根本找不到这次实验需要的结构，比如kernel/memlayout.h/USYSCALL，在切换分支前，根本就没有。 前两个实验没有切换，倒是没有影响。这里要学习git的一些知识，暂时没搞透，搞透了再写写 Speed up system calls目的：加速getid()这个系统调用 大意：有一些内核和用户共享的只读页面，来避免模式切换，以此来加快系统调用。这里在kernel/memlayout.h中给你定义了一个虚拟地址USYSCALL，是一个页面的地址，这个页面最开始的地方，又有一个struct，里面放了一个pid。 实现步骤： // 这里基本是仿照着对trapframe的分配和释放来书写代码，都是分配一个页面，都是里面有一个结构体 在kernel/proc.h/struct proc中添加struct usyscall *usyscall;。（用于指向共享页面） 在kernel/proc.c/allocproc()中添加12345678910// Allocate a usyscall page. for lab speedup syscall if((p-&gt;usyscall = (struct usyscall *)kalloc()) == 0)&#123; 、 //这里应该是物理分配和初始化，后面要做一个映射，否则不能保证它所描述的layout freeproc(p); release(&amp;p-&gt;lock); return 0; &#125;// Initialize the usyscall page. for lab speedup syscall p-&gt;usyscall-&gt;pid=p-&gt;pid; 在kernel/proc.c/proc_pagetable()中，添加：1234567// map the share page just below TRAPFRAME, for lab speedup syscall //这里就实现了内存映射，记住，mappages()就是做内存映射的 if(mappages(pagetable, USYSCALL, PGSIZE, (uint64)(p-&gt;usyscall), PTE_R | PTE_U) &lt; 0)&#123; uvmfree(pagetable, 0); return 0; &#125; 在kernrl/proc.c/freeproc()中，添加1234// 释放物理内存if(p-&gt;usyscall) kfree((void*)p-&gt;usyscall); p-&gt;usyscall = 0; 在kernel/proc.c/proc_freepagetable()中，添加：12// 取消映射uvmunmap(pagetable, USYSCALL, 1, 0); 重难点： 理解物理页面的分配和虚拟地址的映射是分两步 了解xv6下虚拟地址空间的组织结构 理解页表的组织结构，就是一个uint64的数组，存放虚拟地址 Print a page table目的：打印pid==1的进程的页表 要点： 这里是多级页表，要依次往下探，所以递归进行 与kernel/vm.c/freewalk()的逻辑和遍历路径一致，freewalk的功能是释放分配给页表的物理内存，取消虚拟地址映射。并且物理内存的释放是从下到上。 实现步骤： 在kernel/exec.c/exec()中的return argc之前，添加：123if(p-&gt;pid==1)&#123; //for lab:print ptl vmprint(p-&gt;pagetable); &#125; 在kernel/vm.c中实现功能：12345678910111213141516171819202122232425262728293031323334// for lab:print ptlvoid fmt_print(int deepth,int i,pte_t pte,uint64 child)&#123; switch(deepth)&#123; case 0:printf(&quot;..&quot;);break; case 1:printf(&quot;.. ..&quot;);break; case 2:printf(&quot;.. .. ..&quot;);break; default:break; &#125; printf(&quot;%d: pte %p pa %p\\n&quot;,i,pte,child);&#125;voidvmprint_func(pagetable_t pagetable,int deepth)&#123; // there are 2^9 = 512 PTEs in a page table. for(int i = 0; i &lt; 512; i++)&#123; pte_t pte = pagetable[i]; //这是一个指针数组，得到了地址 if((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0)&#123; //这个页表条目指向了下一级页表 // this PTE points to a lower-level page table. uint64 child = PTE2PA(pte); //pte转为物理地址，应该说，在直到最底端之前，所谓了pa，都是下一级的虚拟地址而已。 fmt_print(deepth,i,pte,child); vmprint_func((pagetable_t)child,deepth+1); //递归的进行 &#125; else if(pte &amp; PTE_V)&#123; //到底了 uint64 child = PTE2PA(pte); fmt_print(deepth,i,pte,child); //叶子页表，不用递归了 &#125; &#125;&#125;void vmprint(pagetable_t pagetable)&#123; printf(&quot;page table %p\\n&quot;,pagetable); vmprint_func(pagetable,0);&#125; 在kernel/defs.h中找到vm.c对应得地方，添加对vmprint()的原型说明。 重难点： 了解页表的组织结构，实现对页表的递归遍历并打印层次结构信息。 通过对标识位的逻辑运算，判定PTE是否映射有对象。 Detecting which pages have been accessed目的：检测哪些页面的Accessed标志位为1，这里要了解sv39结构的虚拟地址的组成。 实现思路：大体也就是通过遍历页表，检测标志位 实现步骤： 在kernel/riscv.h中定义Accessed标志位：1#define PTE_A (1L &lt;&lt; 6) // 1 -&gt;accessed for lab detect accessed 在kernel/sysproc.c中实现syscall的外壳：12345678910111213141516171819202122232425#ifdef LAB_PGTBLintsys_pgaccess(void) //for lab detecting accessed&#123; // lab pgtbl: your code here. uint64 start_va; //开始的虚拟地址 if(argaddr(0, &amp;start_va) &lt; 0) return -1; int page_num; //页面号 if(argint(1, &amp;page_num) &lt; 0) return -1; uint64 result_va; //存储结果的buffer if(argaddr(2, &amp;result_va) &lt; 0) return -1; struct proc *p = myproc(); if(pgaccess(p-&gt;pagetable,start_va,page_num,result_va) &lt; 0) //真正的功能实现，在vm.c中实现 return -1; return 0;&#125;#endif 在kernel/vm.c中实现功能：1234567891011121314151617181920212223242526// for lab detect accessedint pgaccess(pagetable_t pagetable,uint64 start_va, int page_num, uint64 result_va)&#123; if (page_num &gt; 64) &#123; panic(&quot;pgaccess: too much pages&quot;); return -1; &#125; unsigned int bitmask = 0; int cur_bitmask = 1; int count = 0; uint64 va = start_va; pte_t *pte; for (; count &lt; page_num; count++, va += PGSIZE) &#123; if ((pte = walk(pagetable, va, 0)) == 0) panic(&quot;pgaccess: pte should exist&quot;); if ((*pte &amp; PTE_A)) &#123; bitmask |= (cur_bitmask&lt;&lt;count); *pte &amp;= ~PTE_A; &#125; &#125; copyout(pagetable,result_va,(char*)&amp;bitmask,sizeof(bitmask)); return 0; &#125; 在kernel/defs.h中找到vm.c的位置，添加pgaccess()的原型。 ！！注意，这三个实验的验证是通过make qemu，使用pgtaltest命令来验证。 2.22。ugetpid不通过，不知道为啥。 Lab: traps研究系统调用是如何通过traps机制实现的。 关于traps机制：直译陷阱。异常的一种，请结合csapp笔记来看 实现一个用户级的trap handling Lab: Copy-on-Write Fork for xv6就是实现一个写时复制的fork csapp：fork()为了给这个新进程创建虚拟内存，它创建了当前进程的mm_struct、区域结构和页表的原样副本。 它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。 Lab: Multithreading实现一个用户级的线程包，来实现线程的切换，以此来加快程序运行速度。并且实现一个mem barrier mem barrier机制 Lab: networking为网络接口控制器写一个设备驱动 Lab: locksparallelism、lock：关于锁和并发。有点复杂。不用写上去，搞不定 Lab: file system为xv6系统添加大文件和符号链接 Lab: mmap","categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://dududida.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"摄影学习笔记","slug":"摄影学习笔记","date":"2022-03-14T09:20:30.285Z","updated":"2023-01-09T13:34:44.253Z","comments":true,"path":"2022/03/14/摄影学习笔记/","link":"","permalink":"https://dududida.github.io/2022/03/14/%E6%91%84%E5%BD%B1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"如何减少夜景噪点 降低iso (最好不要高于400) 快门速度变慢 (延长曝光时间) 使用三角架 小知识 如果其他参数不变，曝光时间越长，照片就越亮 感光度过高容易产生噪点 名词解释 EV(Exposure Value,曝光值) 基本可以理解为EV越高，拍摄环境的亮度越高。(文章链接：摄影基础文：什么是EV？)","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://dududida.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[]},{"title":"电线杆子上的人","slug":"story_1","date":"2022-03-08T05:42:23.092Z","updated":"2023-01-09T13:47:01.871Z","comments":true,"path":"2022/03/08/story_1/","link":"","permalink":"https://dududida.github.io/2022/03/08/story_1/","excerpt":"","text":"&emsp;&emsp;电线杆子，一根又一根的电线杆子。电线杆子之间的电线，平行的电线构成了一条直直的，宽敞的道路。&emsp;&emsp;电线杆子上的人就在这样的道路上走着，他们从这里到哪里，他们几乎不休息地走着，他们有时跳跃，有时奔跑。他们偶尔也会停下来，蹲在电线杆子上看着杆子下的人。他们看他们交谈，看他们争吵。&emsp;&emsp;他们真的知道下面的人在讲什么吗？他们不知道，他们是电线杆子上的人，他们只是笑一笑，然后继续向前走去。","categories":[{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://dududida.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[]}],"categories":[{"name":"学习记录","slug":"学习记录","permalink":"https://dududida.github.io/categories/%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"},{"name":"杂七杂八","slug":"杂七杂八","permalink":"https://dududida.github.io/categories/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"}],"tags":[]}